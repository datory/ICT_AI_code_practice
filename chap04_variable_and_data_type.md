변수의 종류

1) 정적 타입 변수: 변수가 한 가지 종류의

2) 동적 타입 변수: 



식별자를 만드는 규칙
- 변수명은 문자, 숫자, 밑줄 기호(_)를 이용해 만든다.
- 숫자로 시작하는 변수명을 만들 수 없다.
* 식별자를 밑줄 기호로 시작할 수는 있지만 파이썬에서는 식별자가 밑줄 기호로 시작하거나 끝나면 다른 의미를 가진다.
- 대소문자를 구분한다.
- 공백을 포함할 수 없다.
- 밑줄 이외의 기호는 변수에 이용할 수 없다.
- 예약어(Reserved word)는 변수명으로 이용할 수 없다.
* 한글로도 식별자를 지정할 수는 있지만 지향하지 않는다.
* 파이썬에서 $은 사용이 안된다.



### 파이썬 데이터 타입

1) primitive type
하나의 값만 저장할 수 있는 타입
- int
(정수 타입은 크기가 딱 정해져있다. C나 Java에서는 가질 수 있는 범위가 달라진다. 이러한 특징은 데이터분석이나 인공지능에서 엄청나게 큰 장점이다.)
(C언어에서 int는 4바이트 타입을 가진다.)
(파이썬에서의 정수는 메모리가 허용하는 범위내에서 제한없이 사용할 수가 있다.)
C언어에서는 구조체 만들고 메모리 할당하고 새로 만들어야 한다.
- float => IEEE754, 8Byte: 64bit => 1|12|51
(실수값을 저장하는 값은 국제표준으로 딱 정해져 있다. 따라서 8바이트 기준을 갖는 부동소수형이다. 1이 부호를 저장하는 비트이고, 12개가 지수를 저장하는 비트, 51이 가수를 저장하는 비트이다. 따라서 51비트만 가수로 저장하고 나머지는 버리는 것이다.)
- bool
- complex
(특이하게도 파이썬에서는 복소수를 기본으로 지원한다. 복소수는 복잡한 연산이나 전자에서 사용한다. 일반적인 상황에서는 복소수를 사용하지 않는다.)


2) container type
한번에 여러개의 값을 저장할 수 있는 타입
- str
(파이썬에서는 단일 문자타입이 없다. 문자들이 모여서 문자열이 되어서 str은 컨테이너다. 하지만 컨테이너이기는 하지만 그냥 문자열이다. 실제적인 저장하고 관리하는 컨테이너는 아니다.)
- list
- tuple
- set
- dict


파이썬에서 큰따옴표와 작은따옴표를 구분하지 않는 이유:
파이썬에서는 단일 문자 타입이 없다. 다른 언어에서 작은따옴표는 하나의 문자를, 큰따옴표는 문자열을 나타내기 위해서 사용한다. 하지만 파이썬에서는 작은따옴표 문자열이 기본이기에 작은따옴표를 지향한다.
큰따옴표 안에서 큰따옴표는 사용이 불가하다.
작은따옴표 안에서 작은따옴표는 사용이 불가하다.


'''의 쓰임
주석과 다음줄 쓰기


문자열 연결 연산
문자열 반복 연산
항상 새로운 문자열을 만들지, 원래 자신의 문자열을 만들지 않는다.

4장에서는 문자열을 만들고 사용하는 방법만 나오고 문자열을 다루는 방법은 9장에서 나온다.



!!! 파이썬에서의 컨테이너는 모든 종류의 값을 저장할 수 있다.
리스트안에 리스트, 튜플, 셋, 딕셔너리 모든게 다 저장가능하고
이것은 튜플, 셋, 딕셔너리도 마찬가지이다.



!!! 순방향 인덱스는 스텝을 생략할 수 있지만
역방향 인덱스를 이용한 슬라이싱은 스텝을 생략할 수 없고 스텝을 지정할때는 음수값이어야 한다.



!!!!! 원래 del 명령은 식별자를 제거하는 명령이다. 변수 뿐만이 아니라 함수와 클래스, 리스트도 제거할 수 있다.

컨테이너를 생성한다 = 여러 변수를 동시에 생성한다.





리스트 다루기

리스트명.메소드명()
append는 항상 마지막 값만 추가할 수가 있다.
중간에 값을 추가하고 싶으면 insert를 사용.

객체명.객체명
객체명.메소드명()

!!! remove는 존재하는 값만 제거 가능하고
존재하더라도 첫번째 값만 제거한다. 따라서 remove는 해당 값이 존재하는지부터 확인하고 사용해야한다.


!!!!! 자료구조에서 가장 많이 쓰이는 것은 Stack과 Q 이다.

!!!!! Stack: first in, last out
push와 pop
1, 2, 3순으로 들어간다면(push)
3, 2, 1순으로 나온다(pop)
# 파이썬에는 push라는 이름의 메소드는 없지만 똑같은 기능을 하고 있는 append 메소드가 존재한다.


!!! index(): remove()와 마찬가지로 먼저 값이 존재하는지 확인하고 사용해야한다.
하지만 remove()와는 다르게 추가적으로 내가 시작하는 위치를 지정할 수가 있다.



순방향 = 오름차순
역반향 = 내림차순


!!! sort(): 정렬된 새로운 리스트를 만들것 같지만 아니다. 원본 리스트를 정렬한다.

!!!!! 원본 순서가 중요할때가 있지만 원본 순서가 날라가는 경우가 있으니 조심해야 한다. 원본이 손상되는 것이라서 되돌릴 방법이 없다.
원본이 바껴도 상관이 없는 경우도 있지만 바뀌면 안되는 경우도 많으니 꼭 조심하자.




!! reverse(): 리스트 항목을 끝에서부터 역순으로 뒤집는다. (정렬이 아니다) sort()와 같이 원본을 건드린다.












튜플: 한 마디로 읽기전용 리스트다.
컨테이너는 변명할 수 없는 유일한 하나의 값만 가지면 의미가 없다.
컨테이너는 여러개의 값을 가질때 의미가 있다.
기본적으로 하나의 값만 가지는 튜플은 인정하지 않아서 type이 int로 분류된다.
그렇지만 하나의 인자만 가지는 튜플이 필요한 특별한 경우가 있다.
그럴때는 인자 뒤에 콤마를 붙여주면 된다. 콤마를 붙여주면 type이 int가 아닌 tuple로 분류된다.




튜플은 기본은 리스트와 동일하다.
차이점:
리스트는 대괄호, 튜플은 괄호
정방향 인덱스와 역방향 인덱스 리스트와 튜플 모두 가능하다.
튜플은 값을 변경 할 수 없다.
문자열 튜플을 만들수 있다.
여러 종류의 값을 가진 튜플을 만들 수 있나? 당연히 만들 수 있다. 튜플에 리스트를 저장할 수 있다.
튜플에 저장된 리스트의 내용은 변경 가능한가????
!!!!! 리스트 자체가 제거되거나 리스트 자체가 다른 값으로 변경되는 것은 안되지만 리스트 안에 있는 내용은 변경할 수 있다.
!!!!! 왜냐하면 리스트 자체는 변경 가능하다. 튜플만 변경이 안되는 것이다. 그렇기에 리스트는 튜플과 상관 없이 내용 변경이 가능하다.
튜플 연결 연산과 반복 연산은 가능하다. 리스트와 똑같이 기존의 튜플이 바뀌는 것이 아닌 새로운 값을 만들기 때문이다.
인덱싱이란 기존의 리스트에 저장된 값들을 복사해서 새로운 리스트를 만드는 것이기 때문에 튜플도 인덱싱이 가능하다.
del: 튜플 자체는 식별자라 자체를 삭제하는 것은 가능하다. 하지만 튜플 안에 있는 항목을 제거하는 것은 불가능하다.
in은 가능하다.

원래의 리스트의 내용을 변경시키는 메소드는 튜플에서 사용할 수 없다.
내용 자체를 변경하지 않는 메소드는 index()와 count()다.












세트는 데이터에 순서가 없다.
리스트와 튜플은 사용자가 지정한 순서가 반드시 그 순서대로 저장이 된다.
하지만 세트는 만들때 사용자가 지정한 순서가 바뀔 수 있다. 그리고 중복을 허용하지 않는다.
세트는 값만 저장하는 것이고 인덱스가 없다.
왜냐하면 세트는 저장된 각각의 값들을 사용하려고 있는 컨테이너가 아니다. -> 이것은 리스트다.
세트라는 컨테이너는 집합 연산을 위해서 사용되어지는 컨테이너다.
리스트와 딕트만 저장된 모든 값들을 개별적으로 읽을 수 있고 변경, 삭제, 새로운 값을 추가 할 수 있다.
튜플과 세트는 제한이 있다. 튜플은 읽기만 가능하고 세트는 개별값을 식별할 수 없다.
세트는 새로운 값을 추가하거나 기존의 값을 제거할 수는 있다. 단, 집합 연산을 통해서만 가능하다.
세트는 언제 쓰일까?
고객A리스트와 고객B리스트가 있으면 고객A리스트와 고객B리스트를 
고객A세트와 고객B세트로 형변환을 시킨다. 그리고 나서 합집합 연산을 하면 모든 고객을 만들고
교집합하면 양쪽 고객을 알 수 있고 차집한한 집합을 알고나서
다시 리스트로 바꿔서 사용하는 것이다.
그렇기 때문에 세트라는 것은 

!!!!!! 실제로 데이터저장소는 리스트와 딕트다.
실제 데이터저장소인 리스트와 딕트를 외부에 공개할때 튜플을 사용하는 것이다.
처음부터 튜플을 만드는 경우는 없다. 세트도 마찬가지다.




교집합, 합집합, 차집합
원래의 집합을 변경하지 않고 새로운 집합을 만든다.

메소드 사용하는 것보다 연산자를 사용하는게 훨씬 편해서
intersection, union difference 메소드는 사용하지 않는다.
대신에 &, |, - 연산자를 사용한다.

메소드는 이럴때 필요하다.